#!/usr/bin/env node
import { readFileSync, writeFileSync, readdirSync, statSync, mkdirSync } from 'node:fs';
import { join, dirname, relative, extname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = join(__dirname, '..');

/**
 * Bundle TypeScript files into a single file while preserving types
 * @param {string} entryPoint - Entry file path (e.g., 'src/index.ts')
 * @param {string} outputFile - Output file path (e.g., 'dist/bundle.ts')
 */
function bundleTypeScript(entryPoint, outputFile) {
  const visited = new Set();
  const output = [];

  // Add header
  output.push('// Generated by bundle-ts.js');
  output.push('// This file bundles all TypeScript sources while preserving types');
  output.push('// @ts-nocheck - Skip type checking due to potential duplicate definitions from bundling');
  output.push('');

  function processFile(filePath) {
    const absolutePath = join(projectRoot, filePath);

    if (visited.has(absolutePath)) {
      return;
    }
    visited.add(absolutePath);

    const content = readFileSync(absolutePath, 'utf-8');
    const lines = content.split('\n');
    const processedLines = [];
    let inMultilineExport = false;
    let exportBuffer = [];
    let braceCount = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();

      // Handle multiline export continuation
      if (inMultilineExport) {
        exportBuffer.push(line);

        // Count braces to detect end of export
        for (const char of line) {
          if (char === '{') braceCount++;
          if (char === '}') braceCount--;
        }

        // Check if export statement is complete
        if (braceCount === 0 && (trimmed.endsWith(';') || trimmed.endsWith('}'))) {
          const fullExport = exportBuffer.join('\n');

          // Check if it's a re-export
          if (fullExport.includes(' from ')) {
            const match = fullExport.match(/from\s+['"](.+)['"]/);
            if (match) {
              const importPath = match[1];
              if (!importPath.startsWith('node:') && importPath.startsWith('.')) {
                const resolvedPath = resolveImport(filePath, importPath);
                if (resolvedPath) {
                  processFile(resolvedPath);
                }
              }
            }
            // Comment out the entire re-export
            processedLines.push(...exportBuffer.map(l => `// ${l}`));
          } else {
            // Remove 'export' keyword from the first line
            exportBuffer[0] = exportBuffer[0].replace(/^(\s*)export\s+/, '$1');
            processedLines.push(...exportBuffer);
          }

          inMultilineExport = false;
          exportBuffer = [];
          braceCount = 0;
        }
        continue;
      }

      // Handle import statements
      if (trimmed.startsWith('import ')) {
        const match = trimmed.match(/from\s+['"](.+)['"]/);
        if (match) {
          const importPath = match[1];

          // Skip external imports (node:, npm packages)
          if (importPath.startsWith('node:') || !importPath.startsWith('.')) {
            processedLines.push(`// ${line}`);
            continue;
          }

          // Resolve relative import
          const resolvedPath = resolveImport(filePath, importPath);
          if (resolvedPath) {
            processFile(resolvedPath);
          }

          // Comment out the import
          processedLines.push(`// ${line}`);
        } else {
          processedLines.push(`// ${line}`);
        }
      }
      // Handle export statements
      else if (trimmed.startsWith('export ')) {
        // Check if this is a multiline export (function/class with return type)
        const isMultiline = !trimmed.endsWith(';') && !trimmed.endsWith('}') &&
                           (trimmed.includes('function') || trimmed.includes('class') ||
                            trimmed.includes(': {') || trimmed.includes('Promise<{'));

        if (isMultiline) {
          inMultilineExport = true;
          exportBuffer = [line];
          // Count braces in first line
          for (const char of line) {
            if (char === '{') braceCount++;
            if (char === '}') braceCount--;
          }
          continue;
        }

        // Handle single-line re-exports: export { A, B } from './module'
        const reExportMatch = trimmed.match(/from\s+['"](.+)['"]/);
        if (reExportMatch) {
          const importPath = reExportMatch[1];

          // Skip external imports
          if (importPath.startsWith('node:') || !importPath.startsWith('.')) {
            processedLines.push(`// ${line}`);
            continue;
          }

          // Resolve and process the imported file
          const resolvedPath = resolveImport(filePath, importPath);
          if (resolvedPath) {
            processFile(resolvedPath);
          }

          // Comment out the re-export
          processedLines.push(`// ${line}`);
        }
        // Handle direct exports: export class A {}, export function b() {}, etc.
        else if (trimmed.match(/^export\s+(class|function|const|let|var|interface|type|enum)\s/)) {
          // Keep the declaration but remove 'export' keyword
          processedLines.push(line.replace(/^(\s*)export\s+/, '$1'));
        }
        // Handle export default
        else if (trimmed.startsWith('export default ')) {
          // Comment out export default
          processedLines.push(`// ${line}`);
        }
        // Handle other export forms
        else {
          // Comment out
          processedLines.push(`// ${line}`);
        }
      }
      // Keep all other lines
      else {
        processedLines.push(line);
      }
    }

    output.push(`\n// ===== ${filePath} =====`);
    output.push(processedLines.join('\n'));
  }

  function resolveImport(fromFile, importPath) {
    const fromDir = dirname(join(projectRoot, fromFile));
    let resolved = join(fromDir, importPath);

    // Try adding .ts extension
    if (!extname(resolved)) {
      if (existsSync(resolved + '.ts')) {
        resolved = resolved + '.ts';
      } else if (existsSync(join(resolved, 'index.ts'))) {
        resolved = join(resolved, 'index.ts');
      } else {
        return null;
      }
    }

    return relative(projectRoot, resolved);
  }

  function existsSync(path) {
    try {
      statSync(path);
      return true;
    } catch {
      return false;
    }
  }

  // Start processing from entry point
  processFile(entryPoint);

  // Add exports section at the end
  output.push('\n// ===== Exports =====');
  output.push('// Re-export main types and classes for module usage');
  output.push('export { BaseClient, Domain };');
  output.push('export type { BaseClientOptions };');
  output.push('export type { RequestArgs, RequestOptions, ResponseType, HttpMethod };');
  output.push('export type { LoggerLevel, Logger };');

  // Write output
  const finalOutput = output.join('\n');
  const outputPath = join(projectRoot, outputFile);

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  mkdirSync(outputDir, { recursive: true });

  writeFileSync(outputPath, finalOutput, 'utf-8');

  console.log(`âœ“ Bundled ${visited.size} files into ${outputFile}`);
}

// CLI usage
const args = process.argv.slice(2);
if (args.length < 2) {
  console.error('Usage: bundle-ts.js <entry> <output>');
  console.error('Example: bundle-ts.js src/index.ts dist/bundle.ts');
  process.exit(1);
}

bundleTypeScript(args[0], args[1]);
